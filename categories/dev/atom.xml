<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Dev | Liorr Yehuda Morrison]]></title>
  <link href="http://blog.liorrmorrison.com/categories/dev/atom.xml" rel="self"/>
  <link href="http://blog.liorrmorrison.com/"/>
  <updated>2014-09-08T16:01:54-07:00</updated>
  <id>http://blog.liorrmorrison.com/</id>
  <author>
    <name><![CDATA[Liorr Yehuda Morrison]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Request-Response]]></title>
    <link href="http://blog.liorrmorrison.com/2014/09/07/request-response/"/>
    <updated>2014-09-07T15:12:29-07:00</updated>
    <id>http://blog.liorrmorrison.com/2014/09/07/request-response</id>
    <content type="html"><![CDATA[<p>Request-Response is the fundamental building block of the Internet and computer networking. The systems works likes so:</p>

<p>A personal computer, the <em>client</em>, is used to access a web page stored on a remote database. The database is linked to a computer that acts as the <em>server</em>, which can access the database and provide the requested information to the client. Using a web browser, the client requests the web page from the server, and the server responds to the client with the requested information by accessing the database. It&rsquo;s no coincidence that the words <em>client</em> and <em>server</em> are used for this system, as it&rsquo;s very analogous to a restaurant. The client, or customer, orders the food by telling the server, or waiter, what he/she wants (&ldquo;Hi, I&rsquo;ll have a google burger please&rdquo;). The waiter then goes to the kitchen, the database, gets the order, and serves it to the &ldquo;client&rdquo;/customer. Now it all makes sense why sometimes, when a server experiences higher-than-normal requests, it wont be able to respond to all of them, and will temporarily shut down. This is akin to how a restaurant will often make customers wait during peak hours, because they simple can&rsquo;t handle all those orders at once!</p>

<h4>HTTP</h4>

<p>The &ldquo;language&rdquo; used in this process is called the Hypertext Transper Protocol, and includes request &ldquo;methods&rdquo;, the most oft used being GET, HEAD, POST, and DELETE.</p>

<ul>
<li><p>GET is, as you could guess, is the request for retrieving data.Going to google.com, for example, would use the GET http method.Because it does not modify anything on the server-side, it is considered a &ldquo;safe&rdquo; method.</p></li>
<li><p>HEAD is the same as GET, except that the server only returns <em>metainformation</em>, that is, information about the entity rather than the entity itself. This is typically used in testing whether links are valid or have recently been modified. Because no modification occurs, it is also a safe method.</p></li>
<li><p>POST is the request that the server accept a new piece of information enclosed in the request; a typical example of this is a blog or forum, where clients are adding posts that change the state of the server, or have other side effects (like transferring money or sending an email). Because something is being changed with the POST method, it is not considered a safe
method.</p></li>
<li><p>DELETE is the request that a given piece of information or resource be deleted by the server, like deleting an email. Again, because the state of the server is being changed, it is not considered a safe method.</p></li>
</ul>


<p>During the early years of the Internet, the web was dominated by static websites that, when requested by the client, were generated and didn&rsquo;t change unless another request was made for the most up-to-date version. Today, however, there are a plethora of technologies that allow for dynamic web pages, where there is a constant flow of communication between the client and the server, allowing content to change from moment to moment. The main technology that made these dynamic web pages a reality is AJAX, which is behind almost all of the asynchronous, dynamic web applications that dominate today&rsquo;s Internet. AJAX allows for this <em>asynchronization</em>, where a request can be made in the back-end without having to wait for a response to make another request, thus not being synchronized. These asynchronous requests and responses can happen without having to reload the web page, which is how we see content changing on the website without the website&rsquo;s core structure changing.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing Continued]]></title>
    <link href="http://blog.liorrmorrison.com/2014/09/07/testing-continued/"/>
    <updated>2014-09-07T14:33:58-07:00</updated>
    <id>http://blog.liorrmorrison.com/2014/09/07/testing-continued</id>
    <content type="html"><![CDATA[<p>A few more notes to add about testing.
The entire testing process is comprised of different types of testing, including unit testing, feature testing, and integration testing.</p>

<p>-Unit Testing</p>

<p>Unit testing is the process of testing small units of code before implementing and integrating them into functionalities of a software. For example, if you were building a website that took credit card payments and wanted to check whether or not the user entered in a valid card number, you would want to make sure that the small piece of code that checks for a valid card number actually works before integrating it into the software.</p>

<p>-Integration Testing</p>

<p>The next step after unit testing is integration testing, which tests how those smaller units of code work in tandem. Perhaps several units of code come together to provide a working functionality element of a software, but not the entire working product.</p>

<p>-Feature testing</p>

<p>Feature testing is one of the last steps of the testing process in which the code comes together to form a working, functional product that a user can interface with. Feature testing may or may not be testing of the entire software, but it at the very least tests a major working component. Feature testing is usually less technical and actually involves using the software to ensure it works properly.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing]]></title>
    <link href="http://blog.liorrmorrison.com/2014/09/07/testing/"/>
    <updated>2014-09-07T11:58:09-07:00</updated>
    <id>http://blog.liorrmorrison.com/2014/09/07/testing</id>
    <content type="html"><![CDATA[<p>These days more than ever, testing is a crucial part of agile software development. In a production environment where a developer&rsquo;s code is going to be used by potentially millions of users, the dev needs to have a level of certainty that his/her code is perfectly functional&mdash;or at least, as close to it as possible. Software can have thousands of lines of code running in the back-end, so testing that code in the development process is crucial that all elements of software function properly. This methodology is known as test-driven development (TDD), which can be broken down in the following steps (credit: <a href="joshdavis.com">Josh Davis</a>)</p>

<blockquote><ol>
<li><p>First the developer writes some tests.</p></li>
<li><p>The developer then runs those tests and (obviously) they fail because none of those features are actually implemented.</p></li>
<li><p>Next the developer actually implements those tests in code.</p></li>
<li><p>If the developer writes his code well, then in the next stage he will see his tests pass.</p></li>
<li><p>The developer can then refactor his code, add comments, clean it up, as he wishes because the developer knows that if the new code breaks something, then the tests will alert him by failing.</p></li>
</ol>
</blockquote>

<p>One such tool for TDD in Ruby is called RSpec, which is a Ruby testing framework packaged in a gem that allows the user to write highly readable tests for Ruby code. Here is an example of an RSpec test that tests whether the Hash method actually returns what the programmer expects:</p>

<pre><code class="ruby">describe Hash do
  it "should return a blank instance" do
    Hash.new.should == {}
  end
end
</code></pre>

<p>As you can see, the test reads almost exactly like plain English&mdash;even more so than Ruby!&mdash;with keywords like <code>describe</code>, <code>it</code>, and <code>should</code>. RSpec tests are typically written under the Ruby code in the same file, and are run by opening the file with RSpec instead of Ruby in the command line.</p>

<p>Consider the following method, which takes a string as an argument and obfuscates any social security number the string might contain:</p>

<pre><code class="ruby">def hide_all_ssns(string)
  pattern = /\d{3}.*?\d{2}.*?(\d{4})/
  string.gsub(pattern, 'XXX-XX-\1')
end
</code></pre>

<p>The method uses a regular expression (REGEXP), a generalized pattern that will find matches to the pattern in the string, and will replace the first 5 numbers of the SSN it finds with X&rsquo;s.</p>

<p>Here&rsquo;s a test that will check whether or not the <code>hide_all_ssns(string)</code> method does what it&rsquo;s designed to do:</p>

<pre><code class="ruby">describe "hide_all_ssns" do
  it "is defined as a method" do
    expect(defined?(hide_all_ssns)).to eq "method"
  end

  it "obfuscates any SSNs in the string" do
    expect(hide_all_ssns("234-60-1422, 350-80-0744, 013-60-8762")).to eq "XXX-XX-1422, XXX-XX-0744, XXX-XX-8762"
  end

  it "does not alter a string without SSNs in it" do
    string = "please confirm your identity: XXX-XX-1422"
    expect(hide_all_ssns(string)).to eq string
  end
end
</code></pre>

<p>As you can see, there are three tests: The first checks whether or not <code>hide_all_ssns</code> is a method, the second one checks whether it obfuscates the SSNs, and the third one checks whether it alters a string without any SSN matches - but I didn&rsquo;t even need to explain that! You can see exactly what the test is testing by just reading it!</p>

<p>To test the <code>hide_all_ssns</code> method, simply call the file with RSpec in the terminal like so:</p>

<pre><code class="bash">rspec hide_ssns.rb
</code></pre>

<p>which will return the results of the test in the terminal. If it passes, it will say: <code>3 examples, 0 failures</code>, and if one or more of the tests fail, it will give you a breakdown of what the test expected vs. what it got.</p>

<p>RSpec is the Ruby testing tool, but rest assured that other languages have their own RSpec equivalent, like Jasmine for JavaScript&mdash;which reads very similarly to RSpec.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comp Sci Snippet]]></title>
    <link href="http://blog.liorrmorrison.com/2014/09/01/comp-sci-snippet/"/>
    <updated>2014-09-01T11:24:23-07:00</updated>
    <id>http://blog.liorrmorrison.com/2014/09/01/comp-sci-snippet</id>
    <content type="html"><![CDATA[<p>For my first blog post, a snippet of raw computer science: how are arrays stored in computer memory, as they relate to the Ruby programming language? First, let me marvel for a moment at the many degrees of abstraction between Ruby and what the computer processor ultimately processes: binary, or a series of 0&rsquo;s and 1&rsquo;s. Before knowing anything about computer programming, I used to think that programmers were of a rare nerdy breed of (maybe?) human who know the ins and outs of computers <em>so</em> thoroughly, they&rsquo;re practically computers themselves. This notion was probably influenced by a brainy elementary school classmate I had who, years after knowing him, went on to win a prestigious international coding contest. Perhaps <em>he</em> was one of those (human?) types, but one could theoretically be an excellent programmer without knowing much about how computers work. High-level programming languages&mdash;of which Ruby is an excellent example&mdash;provide that luxury, as their syntax, vocabulary, and flow are highly readable, so much so that a non-programmer could make sense of a basic Ruby program. This point is where the degrees of abstraction come in. Ruby itself is programmed using another language entirely, the C programming language, which, in its heyday, was considered a high-level, many-degrees-of-abstraction language as well. That&rsquo;s not to say C is obsolete â€” by no means! - but it is just fell in the ranks of high-level languages. And C, too, is built on other languages, which, moving down the latter of abstraction, eventually leads to assembly languages, then ultimately to machine code, which is the binary code that the CPU actually reads. Most programmers today, especially web developers, only have command over high-level languages, leaving the lower-level stuff all but unseen.</p>

<p>With all these layers of abstraction between high-level languages like Ruby and machine code, the answer to how arrays are stored in the computer&rsquo;s memory as they relate to Ruby might be&hellip;well, Ruby-like, in that the explanation will be understandable to the human reader, but not explain what is happening deep down in the RAM memory module, which is basically all electricity (there is actually nothing physical happening). An array is a Ruby <code>Class</code> defined by a collection of comma separated elements; you can have an array of numbers like <code>num_array = [1, 2, 3]</code>, an array of strings like <code>str_array = ["hi", "ho", "chitty", "chitty", "bang," "bang"]</code> or an array of any combination of types of elements like <code>mixed_array = [1, "chitty", :oh_my]</code>. When an array is created in Ruby, in addition to storing the array elements, the identity (basically, the &ldquo;address&rdquo; of where that array element lives in the memory) of each array element is also stored. Each Array element is stored in consecutive memory locations as the array&rsquo;s organization suggests, allowing for quick, easy access, rather than being stored at random locations, which would make calling and manipulating the array more time-consuming (even though the difference would be infinitesimal and undetectable to humans).</p>
]]></content>
  </entry>
  
</feed>
