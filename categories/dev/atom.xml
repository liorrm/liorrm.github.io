<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Dev | Liorr Yehuda Morrison]]></title>
  <link href="http://blog.liorrmorrison.com/categories/dev/atom.xml" rel="self"/>
  <link href="http://blog.liorrmorrison.com/"/>
  <updated>2014-11-10T15:41:38-08:00</updated>
  <id>http://blog.liorrmorrison.com/</id>
  <author>
    <name><![CDATA[Liorr Yehuda Morrison]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Event Listeners: The Critical Link]]></title>
    <link href="http://blog.liorrmorrison.com/2014/11/08/event-listeners-the-critical-link/"/>
    <updated>2014-11-08T15:38:35-08:00</updated>
    <id>http://blog.liorrmorrison.com/2014/11/08/event-listeners-the-critical-link</id>
    <content type="html"><![CDATA[<p>JavaScript event listeners are kind of like the nervous system of a website. Without them, the website does not have the ability to sense, or &ldquo;listen to&rdquo;, actions the user can take (such as clicking, pressing keys, loading the page, etc). I first learned event listeners through programming my first JS project, the <a href="http://blog.liorrmorrison.com/dbc/airport">airporter game</a>. Event listeners allow you to change or manipulate HTML/CSS elements when a certain element &ldquo;hears&rdquo; an event. To illustrate this idea, let&rsquo;s take an example from my airport game. It would help you understand this explanation if you played a quick round of the game first! In the game, I have two event listeners, one that targets the entire window and one that targets an HTML element:</p>

<pre><code class="javascript">airbus.addEventListener('click', clearWay)
window.addEventListener('keydown', move)
</code></pre>

<p>Let&rsquo;s analyze the syntax of these event listeners. The functionality of the <code>addEventListener</code> function is obvious enough, but what&rsquo;s going on with the rest of it? You call the <code>addEventListener</code> function on an HTML/DOM element. In the first example, it is being called on <code>airbus</code>, which is an a div in the HTML with the id &ldquo;airbus&rdquo;. If you have played the game, the airbus is the &ldquo;little scoundrel&rdquo; airplane that gets in the way of your progress! Now, what&rsquo;s going on in the parenthesis? The <code>addEventListener</code> function takes two parameters: an event, and a function to run when that event occurs (there is an optional boolean third parameter, but it is pretty technical so I won&rsquo;t discuss it here). In the first example, the event is &lsquo;click&rsquo;, and the function is clearWay. So when the airbus element is clicked, the clearWay function will be run. I defined the clearWay function such that it changes the element&rsquo;s top style to 200px from where it originally was lower down on the runway. How does this manifest? Well, if you click the airbus on the page, it moves up away from the runway! As for the second example, why do we target the window if we really mean to move the other airplane? Well, the &lsquo;keydown&rsquo; event can&rsquo;t really target a particular HTML DOM element. The only part of a web page that can &ldquo;hear&rdquo; it is the window itself! That allows you to use the arrow keys to control the airplane without having to click, scroll over, or do anything to the airplane itself. As you can see, the second event listener executes the &ldquo;move&rdquo; function upon the &lsquo;keydown&rsquo; event (which, in the move function, I limit to just the arrow keys). The move function changes the boeing element&rsquo;s CSS positioning. Event listeners are the link between JavaScript and HTML/CSS elements. Without them, no script would be able communicate with and manipulate the web page!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby &amp; JavaScript: The Big Players of Web Development]]></title>
    <link href="http://blog.liorrmorrison.com/2014/10/31/ruby-and-javascript-the-major-players-of-web-development/"/>
    <updated>2014-10-31T15:52:57-07:00</updated>
    <id>http://blog.liorrmorrison.com/2014/10/31/ruby-and-javascript-the-major-players-of-web-development</id>
    <content type="html"><![CDATA[<p>Delving into the completely different world of JavaScript after having spent over a month getting cozy with Ruby was a bit of a rude awakening. Suddenly my comfort and fluency was out the window &ndash; I felt like I was starting from scratch! What had become second nature in Ruby I now had to research in JavaScript - nooooo! But after spending some hours reading and studying, I feel like I&rsquo;m finally getting my bearings.</p>

<p>JavaScript and Ruby are both powerful object-oriented languages, but they are designed for two completely different purposes. Ruby is a server-side back-end language whose processes don&rsquo;t really have a visual component. Ruby processes and manipulates data and makes calls to the server&rsquo;s database. JavaScript, on the other hand, although it can be used as a server-side language (Google node.js!), is primarily a client-side language that runs in the web browser and is responsible for making websites dynamic and interactive. That&rsquo;s why, despite being a very capable scripting language, JavaScript is typically considered to be a front-end language.</p>

<p>There are many other differences between these two languages as well, the most obvious of which is syntax. Ruby&rsquo;s defining characteristic is the use of the keyword end. You must use end to signal the end of a method definition, class definition, loop, or block. JavaScript, on the other hand, is distinguished by the presence of curly braces and semicolons. Let&rsquo;s compare the following two methods (one written in Ruby, the other in JavaScript) that do the same thing; see if you can figure out which is which!</p>

<pre><code class="javascript">var sum = function(array) {
  var total = 0;
  for (var i = 0; i &lt; array.length; i++) {
    total += array[i];
  }
  return total
}

console.log(sum([1, 2, 3, 4, 5])) // =&gt; 15
</code></pre>

<pre><code class="ruby">def sum(array)
  total = 0
  array.each do |number|
    total += number
  end
  return total
end

sum([1, 2, 3, 4, 5]) #=&gt; 15
</code></pre>

<p>Well? It&rsquo;s pretty obvious, isn&rsquo;t it? You can definitely see the similarities and figure out that each function is doing the same thing, but there are several key differences. For one, the JavaScript loop is completely different-looking from Ruby&rsquo;s <code>#each</code> method. JavaScript also requires (in most cases, though not all) a semicolon at the end of each executable statement, whereas Ruby does not. Ruby determines the extent of methods, loops, and blocks with the end keyword, while JavaScript relies on the meat of a method or loop to be wrapped in curly braces. JavaScript also requires you to use the keyword <code>var</code> at the beginning of each variable assignment.</p>

<p>If I had to pick a favorite, I&rsquo;d choose Ruby hands-down&hellip; I&rsquo;m biased, of course, by my lack of experience as a developer and my familiarity with Ruby. Both languages are incredibly powerful and integral the world of software development, and I&rsquo;m sure my appreciation for JavaScript will increase as I continue to work with it and see its true potential.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Variable Scope: From Local to Global]]></title>
    <link href="http://blog.liorrmorrison.com/2014/10/24/variable-scope-from-local-to-global/"/>
    <updated>2014-10-24T16:35:42-07:00</updated>
    <id>http://blog.liorrmorrison.com/2014/10/24/variable-scope-from-local-to-global</id>
    <content type="html"><![CDATA[<p>Ruby provides programmers with a range of variable types, all defined by their scope &ndash; where they can be accessed. The variables, in order of increasing scope, are local variables, instance variables, class variables, constants, and global variables. Let&rsquo;s dive in to see the accessibility of each of the variable types.</p>

<p>First, let&rsquo;s start with local variables. As their name suggests, local variables have a local scope, limited to the method or block in which they are defined. They must start with a lower-case letter or underscore. Consider the following example:</p>

<pre><code class="ruby">def local_method
  local_variable = "I'm a local variable"
  5.times do
    puts local_variable
  end
end

local_method #=&gt;
              "I'm a local variable"
              "I'm a local variable"
              "I'm a local variable"
              "I'm a local variable"

local_variable =&gt; # NameError: undefined local variable or method `local_variable'
</code></pre>

<p>In this example, the variable <code>local_variable</code> is defined within the method. It can be accessed by the method itself, as we see it successfully executes the code block with the variable; but if we try to access it from outside the method, we get an error message that the variable is undefined. It&rsquo;s undefined because, as a local variable, its scope is limited to within the method itself. What if we were to define a local variable within block within a method?</p>

<pre><code class="ruby">def local_method
  array = [1, 2, 3, 4, 5]
  array.each do |num|
    very_local_variable = "I'm a VERY local variable"
    puts "#{num}. #{very_local_variable}"
  end
  very_local_variable
end

local_method #=&gt;
#                 1. I'm a VERY local variable
#                 2. I'm a VERY local variable
#                 3. I'm a VERY local variable
#                 4. I'm a VERY local variable
#                 5. I'm a VERY local variable
# NameError: undefined local variable or method `very_local_variable'
</code></pre>

<p>What just happened? In this example, <code>very_local_variable</code> is defined within a block that is within a method. When called, the method executed the block successfully, but then when <code>very_local_variable</code> was called outside of the block in which it was defined, ruby told us it was undefined! This example shows you just how limited in scope local variables are: if defined within a block within a method, the method won&rsquo;t even have access to it! Now let&rsquo;s move on to instance variables.</p>

<p>Instance variables are variables limited to one particular instance of a class. They must begin with a single &ldquo;@&rdquo; character. To illustrate the scope of instance variables, consider the following example:</p>

<pre><code class="ruby">class Person
  attr_reader :first_name, :hair_color

  def initialize(first_name, hair_color)
    @first_name = first_name
    @hair_color = hair_color
  end
end

tom = Person.new("Tom", "brown")

tom.first_name #=&gt; "Tom"
tom.hair_color #=&gt; "brown"

muhammad = Person.new("Muhammad", "black")

muhammad.first_name #=&gt; "Muhammad"
muhammad.hair_color #=&gt; "black"
</code></pre>

<p>When we instantiate the Person class, we must give that instance a name and hair color. In the initialize method, these two parameters are turned into instance variables which can then be accessed by other methods in the class, but only on that single instance. For example, if we call <code>tom.first_name</code>, you can see that the program returns the input first name; same with the hair color. If we call these two methods on <code>muhammad</code> we see that we get different results. That is precisely because <code>@first_name</code> and <code>@hair_color</code> are instance variables, only to be used on a single instance of the class. In this case, tom and <code>muhammad</code> are two separate instances of the class Person. But Tom and Muhammad are both people, after all! What if we want them to share some characteristics? For that, we&rsquo;ll need class variables.</p>

<p>Class variables are those available to every instance of that class. What is one trait that all people have in common? Consider a similar example:</p>

<pre><code class="ruby">class Person
  attr_reader :first_name, :hair_color

  def initialize(first_name, hair_color)
    @first_name = first_name
    @hair_color = hair_color
    @@species = "homo sapiens"
  end

  def species
    @@species
  end

end

tom = Person.new("Tom", "brown")

tom.first_name #=&gt; "Tom"
tom.hair_color #=&gt; "brown"
tom.species #=&gt; "homo sapiens"

muhammad = Person.new("Muhammad", "black")

muhammad.first_name #=&gt; "Muhammad"
muhammad.hair_color #=&gt; "black"
muhammad.species #=&gt; "homo sapiens"
</code></pre>

<p>As you can see, the <code>@@species</code> variable is not only available to Tom, but also to Muhammad, and every other instance of <code>Person</code>!</p>

<p>Now let&rsquo;s move on to constants and global variables. These two are similar in scope, but let&rsquo;s start with constants. Constants must be all-caps and, traditionally, are not to be changed. Technically, Ruby does allow the user to change them, but that runs counter to their whole point of being constant, unchanging variables. Like local variables, their scope is slightly fluid. If they are defined within a class, they are available anywhere in the context of that class. If they are defined outside a class, they have global scope, which means they are accessible from anywhere. To demonstrate these concepts, let&rsquo;s return again to our first example:</p>

<pre><code class="ruby">def local_method
  local_variable = "I'm a local variable"
  5.times do
    puts local_variable
  end
end

local_method #=&gt;
              # "I'm a local variable"
              # "I'm a local variable"
              # "I'm a local variable"
              # "I'm a local variable"

local_variable =&gt; # NameError: undefined local variable or method `local_variable'
</code></pre>

<p>What if we turned <code>local_variable</code> into a CONSTANT? We aren&rsquo;t allowed to define CONSTANTS within methods, because technically every time we run the method we&rsquo;d be re-assigning the constant (even though to the same string value, it would still have a different object ID every time, which isn&rsquo;t allowed), so let&rsquo;s define it outside the method.</p>

<pre><code class="ruby">CONSTANT_VARIABLE = "I am a CONSTANT variable"

def local_method
  5.times do
    puts CONSTANT_VARIABLE
  end
end

local_method #=&gt;
              # "I'm a CONSTANT variable"
              # "I'm a CONSTANT variable"
              # "I'm a CONSTANT variable"
              # "I'm a CONSTANT variable"
              # "I'm a CONSTANT variable"
</code></pre>

<p>Look! the method has access to the constant even though it&rsquo;s defined outside of the method! The same goes for global variables, except they actually can be defined within methods:</p>

<pre><code class="ruby">def local_method
  array = [1, 2, 3, 4, 5]
  array.each do |num|
    $global_variable = "I'm a global variable!"
    puts "#{num}. #{$global_variable}"
  end
  $global_variable
end

local_method #=&gt;
                # 1. I'm a global variable!
                # 2. I'm a global variable!
                # 3. I'm a global variable!
                # 4. I'm a global variable!
                # 5. I'm a global variable!
                # "I'm a global variable!"


$global_variable #=&gt; "I'm a global variable!"
</code></pre>

<p>In this example, <code>$global_variable</code> is accessible in the block in which it&rsquo;s defined, in the method itself (this is where a local variable would start giving us problems), and outside the block and method entirely!</p>

<p>I hope you found this little explanation useful; I&rsquo;m off to learn more so I can write more next time! Thanks for reading! :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Classes: Encapsulating State and Behavior]]></title>
    <link href="http://blog.liorrmorrison.com/2014/10/18/ruby-classes-encapsulating-state-and-behavior/"/>
    <updated>2014-10-18T13:55:20-07:00</updated>
    <id>http://blog.liorrmorrison.com/2014/10/18/ruby-classes-encapsulating-state-and-behavior</id>
    <content type="html"><![CDATA[<p>In Ruby, a class is an encapsulation of state and behavior. As we know, Ruby is an object-oriented programming language, so (almost) everything in Ruby is an object. Furthermore, all objects belong to a class, which you can loosely think of as a &ldquo;species&rdquo; of objects. Each class has its own set of characteristics. For example, according to the Ruby docs, the Array class is defined as &ldquo;ordered, integer-indexed collections of any object.&rdquo; The class comes with methods that can be called upon an instance, or example, of that class. Ruby allows users to create classes and to modify existing ones. To better demonstrate the concept of classes, I&rsquo;ll create a class called Person:</p>

<pre><code class="ruby">class Person
  attr_reader :sex, :age, :height, :town, :religion, :occupation

  def initialize(name, sex, age, height, town, religion, occupation)
    @name = name
    @sex = sex
    @age = age
    @height = height
    @town = town
    @religion = religion
    @occupation = occupation
  end

  def sex_change
    if @sex == "male"
      @sex = "female"
    elsif @sex == "female"
      @sex = "male"
    end
  end

  def get_old
    @age += 1
  end

  def grow(new_height)
    @height = new_height
  end

  def move(new_town)
    @town = new_town
  end

  def convert(new_religion)
    @religion = new_religion
  end

  def change_career(new_job)
    @occupation = new_job
  end
end
</code></pre>

<p>To begin, you need to initialize a new instance of that class. Basically, you need to create an individual person from the theoretical class Person. As you can see in the initialize function, I have created a few characteristics each person should have: sex, age, height, town, religion, and occupation. Of course there are many others I could include, but these were the ones that immediately came to mind. When you initialize a new instance of person, you must pass in the above seven arguments; so for example, you would type in:</p>

<pre><code class="ruby">Liorr = Person.new("Liorr", "male", 20, "6'1", "San Francisco", "Agnostic", "Programmer")
</code></pre>

<p>Now that we&rsquo;ve initialized it, Liorr is an instance of the class Person. In the Person class, I have created several attr_readers (attribute readers), which allow the user to access information about Liorr. To see this information, simply type Liorr.sex, Liorr.age, Liorr.height, etc. into the command line, and the values with be returned. I specifically made all these attr_readers rather than attr_accessors because I want to limit the user to changing this information by using only the instance methods I created. As you can see, I had a some fun creating the method names. You can call <code>Liorr.sex_change</code> to change my sex to female, <code>Liorr.get_old</code> to add one year to my age, <code>Liorr.grow(new_height)</code> to change my height to a new input height, <code>Liorr.move(new_town)</code> to change my town to a new input town, <code>Liorr.convert(new_religion)</code> to change my religion to a new input religion, and <code>Liorr.change_career(new_job)</code> to change my occupation to a new input occupation.</p>

<p>Classes are defined by their state and behavior. All of these characteristics &ndash; age, sex, height, religion, etc. &ndash; give the class Person its state, stored in instance variables, while the instance methods &ndash; #grow, #move, #convert, etc. &ndash; give its behavior. I used the Person class as an example because it is easy to demonstrate state and behavior with something so familiar and tangible - people do have all these states and behaviors in the real world! Now all you have to do is think of each class as a different species of object, each endowed with a set of character traits. Arrays and hashes, given the overlap in their states and behaviors, are two closely related classes. To draw another comparison to the real world, you could consider arrays and hashes as you would consider humans and chimpanzees &ndash; very closely related, but ultimately a different species.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Enumerables: Some Mixins for Your Picks-ins]]></title>
    <link href="http://blog.liorrmorrison.com/2014/10/08/enumerables-some-mixins-for-your-picks-ins/"/>
    <updated>2014-10-08T19:05:09-07:00</updated>
    <id>http://blog.liorrmorrison.com/2014/10/08/enumerables-some-mixins-for-your-picks-ins</id>
    <content type="html"><![CDATA[<p>Now almost done with Week 4 of Phase 0, we are plumbing the depths of Ruby and its amazing abilities. For this blog post, I will introduce you to one of Ruby&rsquo;s built-in Enumerable methods. Enumerable is a &ldquo;mixin&rdquo; module in Ruby, meaning that its methods are borrowed from various other class methods. Therefore, you can apply Enumerable methods to various classes, namely arrays and hashes. The method I&rsquo;ll focus in on is the #map method, which can be used on both arrays and hashes. I am going to assume that you have some sense of what the #each method does &mdash; basically, it iterates over an array, calling the given block (the code between braces or after a &lsquo;do&rsquo; statement) once for each element in the array; it passes each array element as a parameter to the block. But it doesn&rsquo;t have the power to actually modify the element. You can use the array&rsquo;s elements to create new data, but not to change the elements themselves, as the following example demonstrates:</p>

<pre><code class="ruby">numbers = [1, 2, 3]

def total(array)
  sum = 0
  array.each do |num|
    sum += num
  end
  sum
end

total(numbers) #=&gt; 6

numbers #=&gt; [1, 2, 3]
</code></pre>

<p>Here, #each is used to add up the elements of the array, and store them in a separate variable. If you were to return the array afterwards, it would be identical. Here&rsquo;s an analogy: the #each method &ldquo;visits&rdquo; each element and can get to know them well, but it can&rsquo;t change them. That&rsquo;s where map comes in. To demonstrate the #map method&rsquo;s differences, let&rsquo;s compare the following two snippets of code:</p>

<pre><code class="ruby">##### using #each #####

numbers =  [1, 2, 3, 4, 5]

numbers.each do |num|
  num * 2
end

#=&gt; [1, 2, 3, 4, 5]

##### using #map #####

array #=&gt; [1, 2, 3, 4, 5]

array.map do |num|
  num * 2
end

#=&gt; [2, 4, 6, 8, 10]

numbers #=&gt; [1, 2, 3, 4, 5]
</code></pre>

<p>The #each method does nothing, while #map successfully executes the block and modifies each element of the array. But does it really change the array? Not exactly. It shows you a modified version of that array with the code block executed, but you can think of that as a temporary glimpse into what it would do it if actually did modify it. As you can see in the above example, if you call the array after calling the code block on it, it remains unchanged. For a true, permanent change, we need the &ldquo;!&rdquo; at the end, or we could save the modified array to a new variable. The exclamation point at the end of a method indicates that the method is what is called a &ldquo;dangerous&rdquo; or &ldquo;destructive&rdquo; method (or colloquially, a &ldquo;bang&rdquo; method) because it permanently changes the composition of the array, as the example below demonstrates:</p>

<pre><code class="ruby">numbers = [1, 2, 3, 4, 5]

numbers.map! do |num|
  num * 2
end

#=&gt; [2, 4, 6, 8, 10]

numbers #=&gt; [2, 4, 6, 8, 10]
</code></pre>

<p>The #map and #map! methods are very useful in making real changes to various data structures. For example, if you had an array of data containing both strings and numbers and wanted to convert all the numbers to strings, you could use #map or #map!, depending on whether you want to make a modified &ldquo;copy&rdquo; of the array for immediate use, or change it permanently.</p>

<p>Here is another example that uses the map method to convert array elements into strings:</p>

<pre><code class="ruby">i_want_pets = ["I", "want", 3, "pets", "but", "only", "have", 2]

def my_array_sorting_method(source)
  source.map {|element| element.to_s}
end

#=&gt; ["I", "want", "3", "pets", "but", "only", "have", "2"]
</code></pre>

<p>And there you have a little introduction to Ruby&rsquo;s Enumerable module! Be sure to check out the <a href="http://ruby-doc.org">Ruby Documentation </a> for more information and to see other Enumerable methods.</p>
]]></content>
  </entry>
  
</feed>
